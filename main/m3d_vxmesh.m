## Copyright (C) 2016 Henning Richter
##
## This function file is part of the 'Mote3D' toolbox for microstructure modelling.
##
## This program is free software; you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 3 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program. If not, see <http://www.gnu.org/licenses/>.

## -*- texinfo -*-
## @deftypefn {Function File} {@var{termflag} =} m3d_vxmesh(@var{P_mat_ind}, @var{R_vec_ind},
## @var{box_length}, @var{el_number}, @var{el_type}, @var{termflag})
##
## Generate a regular hexahedral mesh ("voxel mesh") of the random
## particulate microstructure for import into Abaqus(TM) CAE software.
##
## Discretize the spherical particles defined by particle centres @var{P_mat_ind}
## and particle radii @var{R_vec_ind} within the cubical domain with edge length
## @var{box_length}.  Generate a voxel mesh with specified number of elements
## @var{el_number} and element type @var{el_type}.  Create file "Abq_voxel_mesh.py"
## that contains the resulting voxel mesh for import into Abaqus(TM) CAE software.
## Return the status flag @var{termflag}.
## @end deftypefn
## @cindex m3d_vxmesh

## Author: Henning Richter <henning.richter@dlr.de>
## Created: April 2016
## Keywords: voxel mesh, random periodic microstructure

function [termflag] = m3d_vxmesh(P_mat_ind, R_vec_ind, box_length, el_number, el_type, termflag)

  ## Generate voxel mesh:
  el_factor = double(box_length)/(double(el_number)-1);

  ## Discretize particles:
  [X, Y, Z] = meshgrid(box_length:el_factor:2*box_length);
  Dmesh = repmat(int8(0), [length(X), length(Y), length(Z)]);
  dtemp = repmat(int8(0), [length(X), length(Y), length(Z)]);

  for (i = 1:1:length(P_mat_ind(:,2)))
    dtemp = (sqrt((X-P_mat_ind(i,2)).^2+(Y-P_mat_ind(i,3)).^2+(Z-P_mat_ind(i,4)).^2) <= R_vec_ind(i,2));
    Dmesh(:,:,:,i) = dtemp;
  endfor

  Dmesh = sum(Dmesh, 4);
  Dmesh(Dmesh > 1) = 1;

  ## Create arrays of element numbers:
  Nmesh = repmat(0, [el_number, el_number, el_number]);
  ntemp = repmat(0, [el_number, el_number]);

  for (j = 1:1:el_number)
    for (k = (((j*el_number)-el_number)+1):1:(j*el_number))
      ntemp(k,:) = ((((k*el_number)-el_number)+1):1:(k*el_number));
    endfor
  endfor

  ## Match element numbering scheme:
  ntemp = fliplr(ntemp);

  for (l = 1:1:el_number)
    Nmesh(:,:,l) = ntemp((((l*el_number)-el_number)+1):1:(l*el_number),:);
  end

  ## Assign element numbers:
  N_prtcl = unique(Dmesh.*Nmesh);
  N_prtcl = N_prtcl(N_prtcl ~= 0);
  N_pore = (1:1:(el_number^3))';
  N_pore = setdiff(N_pore, N_prtcl);

  ## Check for consistency:
  if (numel(Dmesh) ~= numel(Nmesh) || nnz(Dmesh) ~= length(N_prtcl))
    error("Voxel mesh generation failed.");
  endif

  ## Generate mesh script:
  fi3 = fopen("Abq_voxel_mesh.py", "wt");
  fprintf(fi3,"##\n");
  fprintf(fi3,"## Header:\n");
  fprintf(fi3,"## Abaqus(TM) CAE voxel mesh generated by Mote3D (www.github.com/Mote3D).\n");
  fprintf(fi3,"## Created on %s.\n", strftime("%a, %e %b %Y, at %T", localtime(time())));
  fprintf(fi3,"##\n");
  fprintf(fi3,"\n");
  fprintf(fi3,"\n");
  fprintf(fi3,"# Do not delete the following import lines:\n");
  fprintf(fi3,"from abaqus import *\n");
  fprintf(fi3,"from abaqusConstants import *\n");
  fprintf(fi3,"import __main__\n");
  fprintf(fi3,"\n");
  fprintf(fi3,"import section\n");
  fprintf(fi3,"import regionToolset\n");
  fprintf(fi3,"import displayGroupMdbToolset as dgm\n");
  fprintf(fi3,"import displayGroupOdbToolset as dgo\n");
  fprintf(fi3,"import sketch\n");
  fprintf(fi3,"import part\n");
  fprintf(fi3,"import assembly\n");
  fprintf(fi3,"import mesh\n");
  fprintf(fi3,"import visualization\n");
  fprintf(fi3,"import time\n");
  fprintf(fi3,"\n");
  fprintf(fi3,"\n");

  ## Initialize Model:
  fprintf(fi3,"##\n");
  fprintf(fi3,"## Model:\n");
  fprintf(fi3,"##\n");
  fprintf(fi3,"start = time.clock()\n");
  fprintf(fi3,"models = mdb.Model(name='Model-1')\n");
  fprintf(fi3,"\n");

  ## Save model parameters:
  fprintf(fi3,"##\n");
  fprintf(fi3,"## Model parameters:\n");
  fprintf(fi3,"##\n");
  fprintf(fi3,"box_length = %f\n", box_length);
  fprintf(fi3,"\n");
  fprintf(fi3,"N_prtcl = (\n");
  fprintf(fi3,"    %i, %i, %i, %i, %i, %i, %i, %i, %i, %i,\n", N_prtcl);
  fprintf(fi3,"    )\n");
  fprintf(fi3,"\n");
  fprintf(fi3,"N_pore = (\n");
  fprintf(fi3,"    %i, %i, %i, %i, %i, %i, %i, %i, %i, %i,\n", N_pore);
  fprintf(fi3,"    )\n");
  fprintf(fi3,"\n");

  ## Generate model:
  fprintf(fi3,"##\n");
  fprintf(fi3,"## Model generation:\n");
  fprintf(fi3,"##\n");
  fprintf(fi3,"s = mdb.models['Model-1'].ConstrainedSketch(name='__profile__',\n");
  fprintf(fi3,"    sheetSize=50.0)\n");
  fprintf(fi3,"gs, vs, ds, cs = s.geometry, s.vertices, s.dimensions, s.constraints\n");
  fprintf(fi3,"s.rectangle(point1=(box_length, box_length), point2=(2*box_length, 2*box_length))\n");
  fprintf(fi3,"\n");
  fprintf(fi3,"p = mdb.models['Model-1'].Part(name='Mote3D', dimensionality=THREE_D,\n");
  fprintf(fi3,"    type=DEFORMABLE_BODY)\n");
  fprintf(fi3,"p = mdb.models['Model-1'].parts['Mote3D']\n");
  fprintf(fi3,"p.BaseSolidExtrude(sketch=s, depth=box_length)\n");
  fprintf(fi3,"\n");

  ## Create assembly:
  fprintf(fi3,"##\n");
  fprintf(fi3,"## Assembly:\n");
  fprintf(fi3,"##\n");
  fprintf(fi3,"a = mdb.models['Model-1'].rootAssembly\n");
  fprintf(fi3,"session.viewports['Viewport: 1'].setValues(displayedObject=a)\n");
  fprintf(fi3,"session.viewports['Viewport: 1'].view.setViewpoint(viewVector=(1,1,1),\n");
  fprintf(fi3,"    cameraUpVector=(0,1,0))\n");
  fprintf(fi3,"session.viewports['Viewport: 1'].view.zoom(zoomFactor=0.75, mode=ABSOLUTE)\n");
  fprintf(fi3,"session.viewports['Viewport: 1'].assemblyDisplay.geometryOptions.setValues(\n");
  fprintf(fi3,"    datumPoints=OFF, datumAxes=OFF, datumPlanes=OFF, datumCoordSystems=OFF)\n");
  fprintf(fi3,"a.DatumCsysByDefault(CARTESIAN)\n");
  fprintf(fi3,"a = mdb.models['Model-1'].rootAssembly\n");
  fprintf(fi3,"p = mdb.models['Model-1'].parts['Mote3D']\n");
  fprintf(fi3,"a.Instance(name='Mote3D-1', part=p, dependent=OFF)\n");
  fprintf(fi3,"a.translate(instanceList=('Mote3D-1', ), vector=(-box_length, -box_length, 0.0))\n");
  fprintf(fi3,"a.regenerate()\n");
  fprintf(fi3,"\n");

  ## Create orphan mesh:
  fprintf(fi3,"##\n");
  fprintf(fi3,"## Mesh:\n");
  fprintf(fi3,"##\n");
  fprintf(fi3,"partInstances = (a.instances['Mote3D-1'], )\n");
  fprintf(fi3,"partCells = a.instances['Mote3D-1'].cells\n");
  fprintf(fi3,"partAllEdges = a.instances['Mote3D-1'].edges\n");
  fprintf(fi3,"partEdge = a.instances['Mote3D-1'].edges.findAt((box_length, box_length, 0.5*box_length), )\n");
  fprintf(fi3,"a.setMeshControls(regions=partCells, elemShape=HEX, technique=SWEEP,\n");
  fprintf(fi3,"    algorithm=ADVANCING_FRONT, allowMapped=TRUE)\n");
  fprintf(fi3,"a.setSweepPath(region=partCells[0], edge=partEdge, sense=FORWARD)\n");
  fprintf(fi3,"a.seedEdgeByNumber(edges=partAllEdges, number=%i, constraint=FIXED)\n", el_number);
  fprintf(fi3,"a.generateMesh(regions=partInstances)\n");
  fprintf(fi3,"elementType = mesh.ElemType(elemCode=%s, elemLibrary=STANDARD)\n", el_type);
  fprintf(fi3,"a.setElementType(regions=(partCells, ), elemTypes=(elementType, ))\n");
  fprintf(fi3,"session.viewports['Viewport: 1'].partDisplay.meshOptions.setValues(meshTechnique=ON)\n");
  fprintf(fi3,"session.viewports['Viewport: 1'].partDisplay.setValues(mesh=ON)\n");
  fprintf(fi3,"\n");
  fprintf(fi3,"a = mdb.models['Model-1'].rootAssembly\n");
  fprintf(fi3,"a.PartFromInstanceMesh(name='MeshMote3D')\n");
  fprintf(fi3,"a.features['Mote3D-1'].suppress()\n");
  fprintf(fi3,"p = mdb.models['Model-1'].parts['MeshMote3D']\n");
  fprintf(fi3,"a.Instance(name='MeshMote3D-1', part=p, dependent=ON)\n");
  fprintf(fi3,"session.viewports['Viewport: 1'].setValues(displayedObject=p)\n");
  fprintf(fi3,"\n");

  ## Assign element sets:
  fprintf(fi3,"##\n");
  fprintf(fi3,"## Element sets:\n");
  fprintf(fi3,"##\n");
  fprintf(fi3,"p = mdb.models['Model-1'].parts['MeshMote3D']\n");
  fprintf(fi3,"\n");
  fprintf(fi3,"S_pore = mdb.models['Model-1'].parts['MeshMote3D'].elements[0:0]\n");
  fprintf(fi3,"S_prtcl = mdb.models['Model-1'].parts['MeshMote3D'].elements[0:0]\n");
  fprintf(fi3,"\n");
  fprintf(fi3,"for it1 in N_pore:\n");
  fprintf(fi3,"    S_pore += mdb.models['Model-1'].parts['MeshMote3D'].elements[(it1-1):it1]\n");
  fprintf(fi3,"    \n");
  fprintf(fi3,"for it2 in N_prtcl:\n");
  fprintf(fi3,"    S_prtcl += mdb.models['Model-1'].parts['MeshMote3D'].elements[(it2-1):it2]\n");
  fprintf(fi3,"    \n");
  fprintf(fi3,"p.Set(elements=S_pore, name='Elset_pore')\n");
  fprintf(fi3,"p.Set(elements=S_prtcl, name='Elset_particles')\n");
  fprintf(fi3,"p.deleteElement(elements=p.sets['Elset_pore'], deleteUnreferencedNodes=ON)\n");
  fprintf(fi3,"del mdb.models['Model-1'].parts['MeshMote3D'].sets['Elset_pore']\n");
  fprintf(fi3,"\n");
  fprintf(fi3,"a = mdb.models['Model-1'].rootAssembly\n");
  fprintf(fi3,"a.regenerate()\n");
  fprintf(fi3,"\n");
  fprintf(fi3,"end = time.clock()\n");
  fprintf(fi3,"print 'Computation time [sec]:', (end-start)\n");
  fprintf(fi3,"\n");
  fclose(fi3);
  termflag = 1;

endfunction
